# Benchmark for performance testing of C++ and Java memory managers

This repository contains a set of benchmarks that are identical in both languages for testing the performance of C++ and Java memory managers. Benchmarks are configured via the benchmarks_config.txt configuration file and random input data is generated by the dataGen.py script.

## Requirements

Before you start, make sure you have the following tools installed.

In brackets are the versions on which I built all this, so everything works exactly on them:
- **C++ Clang compiler** (18.1.3)
- **Java SDK** (JDK21)
- **Gradle** (8.12) for building the Java part of the project
- **CMake** (3.31.5) for building the C++ part of the project
- **Python** (3.12.1 or higher, will not affect the benchmark results) for generating input data files

## Installation Benchmarks
### Step 1: Clone a repository
```bash
git clone https://github.com/lopata29435/Comparison-of-Java-vs.-C-Memory-Management-Performance-Benchmarks.git
cd Comparison-of-Java-vs.-C-Memory-Management-Performance-Benchmarks/
```
### Step 2: Build Makefile
```bash
make build
```

## Running benchmarks

### Step 1: Preparing the configuration file
Benchmarks are managed through a configuration file. This file defines the parameters for each benchmark.

below is the structure of the file, #mutable is labelled with the fields to be changed
```ini
[ByteBench]
iterations= #mutable
allocation_size= #mutable

[ByteNewBench]
iterations= #mutable
allocation_size= #mutable

[ComplexObjectBench]
iterations= #mutable
element_count= #mutable

[AllocatorBench]
sizes_length= #mutable
allocation_sizes_file=../../data/AllocatorBench/allocation_sizes.txt

[AllocatorThreadBench]
sizes_length= #mutable
allocation_sizes_file=../../data/AllocatorThreadBench/allocation_sizes.txt
threads_num= #mutable

[MemoryFragmentationBench]
sizes_length= #mutable
allocation_sizes_file=../../data/MemoryFragmentationBench/allocation_sizes.txt
free_patterns_file=../../data/MemoryFragmentationBench/free_patterns.txt

[RecursiveAllocationBench]
depth= #mutable
allocation_size= #mutable

[MemoryAccessBench]
element_count= #mutable
indices_length= #mutable
access_indices_file=../../data/MemoryAccessBench/access_indices.txt
```

### Step 2: Generate input data files

The benchmarks require input data files such as allocation_sizes.txt, access_indices.txt, and free_patterns.txt. These files contain random values that simulate different memory allocation sizes, access patterns, and memory fragmentation.

Use the provided Python script to generate these files based on the configuration file. The script will automatically create the necessary directories and populate the files with random data.

Run the Python script:
```bash
python3 dataGen.py
```
You can also specify the --max-power parameter. This parameter sets the limit of the maximum size of allocated memory in randomly generated data. If for example --max-power 10, the maximum size will be 2^10 bytes. default value is 12. I strongly advise against making this value greater than 20.
```bash
python3 dataGen.py --max-power 10
```

### Step 3: Run benchmarks
```bash
make run
```

## Configuration File Details
The configuration file (benchmark_config.txt) defines the parameters for each benchmark. Below is an explanation of the various sections and their options:

### ByteBench
- **iterations**: The number of iterations for the benchmark. Each iteration performs a memory allocation.
- **allocation_size**: The size of memory allocated in each iteration (in bytes).

### ByteNewBench.
- **iterations**: The number of iterations for the benchmark.
- **allocation_size**: The size of memory allocated in each iteration using the `new` operator (in bytes).

### ComplexObjectBench
- **iterations**: The number of iterations for the benchmark.
- **element_count**: The number of complex objects (such as structures or classes) to be allocated in each iteration.

### AllocatorBench
- **sizes_length**: The number of memory allocation sizes to generate.
- **allocation_sizes_file**: Path to the file containing the memory allocation sizes for the benchmark (generated by a Python script).

### AllocatorThreadBench
- **sizes_length**: Number of memory allocation sizes to generate.
- **allocation_sizes_file**: Path to the file containing the memory allocation sizes for the benchmark.
- **threads_num**: The number of threads for the multitasking memory allocation benchmark.

### MemoryFragmentationBench
- **sizes_length**: Number of memory allocation sizes to generate.
- **allocation_sizes_file**: Path to the file containing the memory allocation sizes for the benchmark.
- **free_patterns_file**: Path to the file containing the memory freeing patterns (random values 0 or 1) for the fragmentation simulation.

### RecursiveAllocationBench
- **depth**: Recursive memory allocation depth.
- **allocation_size**: The size of memory allocated at each recursion level (in bytes).

### MemoryAccessBench
- **element_count**: The number of elements in the array to be accessed.
- **indices_length**: The number of random indices to access in the array.
- **access_indices_file**: Path to the file containing the indices to be accessed in the benchmark.

## Description of benchmark scenarios

### ByteBench
Benchmark to measure the performance of fixed-size memory allocation. Each iteration performs memory allocation of the specified size. Malloc is used for allocation.

### ByteNewBench
Benchmark to measure memory allocation performance using `new` operator. Each iteration performs a memory allocation of the specified size using the `new` operator.

### ComplexObjectBench
Benchmark for allocating memory for complex objects with a specified number of elements. Each iteration allocates memory for a complex object the specified number of iterations. A complex object is a class with a field containing a vector of the specified size.

### AllocatorBench
Benchmark for testing memory allocation using different sizes. The sizes to be allocated are generated in a Python script and passed to the benchmark via a file.

### AllocatorThreadBench
Benchmark for multitasking memory allocation testing. Uses several threads to simulate real multitasking conditions, each of which allocates memory of different sizes.

### MemoryFragmentationBench
Benchmark for simulating memory fragmentation. Includes testing of memory allocation and release with different sizes and random memory release patterns.


### RecursiveAllocationBench
Benchmark for testing recursive memory allocation. Each iteration performs recursive memory allocation with specified depth and size at each level.

### MemoryAccessBench
Benchmark for measuring memory access performance. Each access is performed on random indices in an array with a specified number of elements.

## Latest Benchmarks results

### C++ Benchmark Results
```
-----------------------Byte Bench--------------------------------------
Time for 100000000 allocations of size 100 bytes: 4729.9 milliseconds
Time for 100000000 deallocations: 5309.42 milliseconds
-----------------------Complex Object Bench--------------------------------
Time to allocate and free 50000000 primitive integers: 0 milliseconds
Time to allocate and free 50000000 complex objects: 5204.37 milliseconds
-----------------------Allocator bench-------------------------------------
Time for 100000 allocations: 106 milliseconds
Max memory used: 269696512 bytes
-----------------------Allocator Thread Bench------------------------------
Threads Num is: 40
Time for 100000 allocations: 8256 milliseconds
Max memory used: 268259328 bytes
-----------------------Memory Fragmentation Bench--------------------------
Fragmentation test for 10000000 allocations with predefined sizes and free patterns: 2317.1 milliseconds
-----------------------Recursive Allocation Bench--------------------------
Recursive allocation test with depth 100000 and allocation size 32768 bytes: 6353.12 milliseconds
-----------------------Memory Access Bench---------------------------------
Memory access test for 100000 accesses in memory block of size 400000000 bytes: 0.1461 milliseconds
```

### Java Benchmark Results
```
-----------------------Byte Bench------------------------------------------
Time for 100000000 allocations of size 100 bytes: 1961.0 milliseconds
Time for 100000000 deallocations: 385.0 milliseconds
-----------------------Complex Object Bench--------------------------------
Time to allocate and free 50000000 primitive integers: 2.0 milliseconds
Time to allocate and free 50000000 complex objects: 9798.0 milliseconds
-----------------------Allocator Bench-------------------------------------
Time for 100000 allocations: 89 milliseconds
Max memory used: 269696512 bytes
-----------------------Allocator Thread Bench------------------------------
Threads Num is: 40
Time for 100000 allocations: 1851 milliseconds
Max memory used: 268259328 bytes
-----------------------Memory Fragmentation Bench--------------------------
Fragmentation test for 10000000 allocations with predefined sizes and free patterns: 1654.7672 milliseconds
-----------------------Recursive Allocation Bench--------------------------
Recursive allocation test with depth 100000 and allocation size 32768 bytes: 929.6657 milliseconds
-----------------------Memory Access Bench---------------------------------
Memory access test for 100000 accesses in memory block of size 400000000 bytes: 1.2889 milliseconds
```

### JavaJMH Benchmark Results
```
-----------------------Byte Bench------------------------------------------
Benchmark                      (allocationSize)  (iterations)  Mode  Cnt     Score     Error  Units
ByteBench.measureAllocation                 100     100000000  avgt    5  2737.412 ± 986.227  ms/op
ByteBench.measureDeallocation               100     100000000  avgt    5    ≈ 10⁻⁶            ms/op
-----------------------Complex Object Bench--------------------------------
Benchmark                                    (complexSize)  (iterations)  Mode  Cnt     Score     Error  Units
ComplexObjectBench.measureAllocateComplex             1000      50000000  avgt    5  8886.012 ± 298.373  ms/op
ComplexObjectBench.measureAllocatePrimitive           1000      50000000  avgt    5    ≈ 10⁻⁶            ms/op
-----------------------Allocator Bench-------------------------------------
Benchmark                    Mode  Cnt   Score    Error  Units
AllocatorBench.runBenchmark  avgt    5  32.940 ± 10.723  ms/op
-----------------------Allocator Thread Bench------------------------------
Benchmark                          Mode  Cnt     Score     Error  Units
AllocatorThreadBench.runBenchmark  avgt    5  1891.430 ± 173.826  ms/op
-----------------------Memory Fragmentation Bench--------------------------
Benchmark                                      Mode  Cnt     Score     Error  Units
MemoryFragmentationBench.measureFragmentation  avgt    5  1309.771 ± 123.084  ms/op
-----------------------Recursive Allocation Bench--------------------------
Benchmark                                            (allocationSize)  (depth)  Mode  Cnt    Score     Error  Units
RecursiveAllocationBench.measureRecursiveAllocation             32768   100000  avgt    5  717.849 ± 293.604  ms/op
-----------------------Memory Access Bench---------------------------------
Benchmark                              Mode  Cnt   Score   Error  Units
MemoryAccessBench.measureMemoryAccess  avgt    5  24.793 ± 1.083  ms/op
```

### Results comparision
| Benchmark | C++ | Java | JavaJMH | Units |
|-----------|------|------|--------|-------|
| Byte bench allocation | 4729.9 | 1961.0 | 2737.412 | ms |
| Byte bench deallocation | 5309.42 | 385.0 | N/A | ms |
| Primitive object bench allocation and deallocation | 0.0 | 2.0 | N/A | ms |
| Complex object bench allocation and deallocation | 5204.37 | 9798.0 | 8886.012 | ms |
| Allocator bench | 106.0 | 89.0 | 32.94 | ms |
| Allocator thread bench | 8256.0 | 1851.0 | 1891.43 | ms |
| Memory fragmentation bench | 2317.1 | 1654.7672 | 1309.771 | ms |
| Recursive allocation bench | 6353.12 | 929.6657 | 717.849 | ms |
| Memory access bench | 0.1461 | 1.2889 | 24.793 | ms |


![Benchmark runtime graph](benchmark_chart.png)
